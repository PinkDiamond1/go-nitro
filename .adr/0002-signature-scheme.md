## 0002 -- State Signature Scheme

Our state signing scheme involves encoding a data structure into a string of bytes, hashing those and signing the hash. Signing a hash is important because it protects against leakage of the private key -- since the hash is unpredicatble it cannot be crafted maliciously by an adversary (even if the preimage has been prepared by that adversary).

There remains a potential issue with signatures being resued in unintended ways.

Consider an encoding collision p = encode(a,b) = encode'(a',b') = p'. Put otherwise, the bytes p could be encoded / decoded in two different ways (perhaps the intended way plus another unintended way), giving rise to distinct variables a' != a, b' != b. If these distinct sets of variables and encoding functions result in the same preimage for the hashing and signing steps, the same signature could be "valid" for both sets.

We address this issue as follows:

Nitro clients should verify the decoding from the contract where funds are locked. Notwithstanding things like upgradeable contracts, if we use `abi.encode` this decoding is deterministic and therefore totally predictable. (Contrast this with using something like `abi.encodePacked`, where multiple inputs encode to the same bytes -- as a consequence there is no decoder for `abi.encodePacked` as the there is no unique pre-image).

A signature on `h(p)` might get "replayed" to a contract with a different decoder, with unintended effects -- but as long as no funds are ever sent there, there should be no issue. We do need to ensure that the signature is generated by a truly ephemeral key, though -- the only place where that key should have meaning is for signing nitro state channel updates.

Hashing the outcome and appdata parts of the state separately, and mixing them with the remaining fields before hashing and signing, would make it much harder (effectively impossible) to engineer the malicious decoder contract. But this extra protection is unnecessary given the above.
